{"ast":null,"code":"import { createEffect, ofType } from '@ngrx/effects';\nimport { switchMap, map, catchError, tap } from 'rxjs/operators';\nimport { of } from 'rxjs';\nimport * as authActions from '../store/auth.actions';\nimport { AuthJSStrapi } from '../auth';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/effects\";\nimport * as i2 from \"./auth.service\";\nimport * as i3 from \"@angular/router\";\nimport * as i4 from \"@ngrx/store\";\nimport * as i5 from \"src/app/modules/shared/shared.service\";\nexport let AuthEffects = /*#__PURE__*/(() => {\n  class AuthEffects {\n    constructor(actions$, authService, router, store, shared) {\n      this.actions$ = actions$;\n      this.authService = authService;\n      this.router = router;\n      this.store = store;\n      this.shared = shared;\n      this.login$ = createEffect(() => {\n        return this.actions$.pipe(ofType(authActions.login), switchMap(({\n          email,\n          password\n        }) => this.authService.login(email, password).pipe(map(data => authActions.loginSuccess({\n          jwt: data.jwt\n        })), catchError(error => of(authActions.loginFailure({\n          error\n        }))))));\n      });\n      /**\n       * Cuando hace login con otro provider, hace falta ejecutar getMe() porque solamente trae token\n       */\n\n      this.loginSuccess$ = createEffect(() => {\n        return this.actions$.pipe(ofType(authActions.loginSuccess), tap(({\n          jwt\n        }) => {\n          localStorage.setItem('token', jwt);\n          this.store.dispatch(authActions.getMe());\n        }));\n      }, {\n        dispatch: false\n      });\n      this.actualizarUser$ = createEffect(() => {\n        return this.actions$.pipe(ofType(authActions.actualizarUser), switchMap(({\n          usuario\n        }) => this.authService.actualizarUser(usuario).pipe(map(usuario => {\n          localStorage.setItem('usuario', JSON.stringify(usuario));\n          return authActions.actualizarUserSuccess({\n            usuario\n          });\n        }), catchError(error => of(authActions.actualizarUserFailure({\n          error\n        }))))), tap(() => {\n          let route = this.router.url;\n          console.log(route);\n\n          if (route === '/profile/editPassword') {\n            this.shared.sendAlert('success', 'Contraseña actualizada', 'Contraseña actualizada con éxito');\n            this.router.navigate(['/profile']);\n          } else if (route === '/profile/editUser') {\n            this.shared.sendAlert('success', 'Usuario actualizado', 'Informacion de usuario actualizada con éxito');\n            this.router.navigate(['/home']);\n          }\n        }));\n      });\n      this.registrar$ = createEffect(() => {\n        return this.actions$.pipe(ofType(authActions.registrar), switchMap(formData => this.authService.registrar(formData).pipe(map(data => {\n          localStorage.setItem('token', data.jwt);\n          localStorage.setItem('usuario', JSON.stringify(data.user));\n          this.router.navigate(AuthJSStrapi.config.homeRoute);\n          this.store.dispatch(authActions.getMe());\n          return authActions.registrarSuccess({\n            usuario: data.user,\n            jwt: data.jwt\n          });\n        }), catchError(error => of(authActions.registrarFailure({\n          error\n        }))))));\n      });\n      this.getMe$ = createEffect(() => {\n        return this.actions$.pipe(ofType(authActions.getMe), switchMap(() => this.authService.getMe().pipe(map(usuario => {\n          localStorage.setItem('usuario', JSON.stringify(usuario));\n\n          if (this.router.url.includes('login') || this.router.url.includes('register')) {\n            this.router.navigate(AuthJSStrapi.config.homeRoute);\n          }\n\n          return authActions.getMeSuccess({\n            usuario\n          });\n        }), catchError(error => {\n          setTimeout(() => {\n            this.router.navigate(AuthJSStrapi.config.loginRoute);\n          }, 100);\n          this.store.dispatch(authActions.cerrarSesion());\n          return of(authActions.getMeFailure({\n            error\n          }));\n        }))));\n      });\n      this.cerrarSesion$ = createEffect(() => {\n        return this.actions$.pipe(ofType(authActions.cerrarSesion), tap(() => {\n          localStorage.removeItem('token');\n          localStorage.removeItem('usuario');\n          localStorage.removeItem('error');\n          this.router.navigate(AuthJSStrapi.config.loginRoute);\n        }));\n      }, {\n        dispatch: false\n      });\n      this.getRecoveryToken$ = createEffect(() => {\n        return this.actions$.pipe(ofType(authActions.getRecoveryToken), switchMap(({\n          email\n        }) => this.authService.getRecoveryToken(email).pipe(map(data => authActions.getRecoveryTokenSuccess({\n          payload: data\n        })), catchError(error => of(authActions.getRecoveryTokenFailure({\n          error: error\n        }))))));\n      });\n      this.passwordRecovery$ = createEffect(() => {\n        return this.actions$.pipe(ofType(authActions.passwordRecovery), switchMap(({\n          code,\n          password,\n          passwordConfirmation\n        }) => this.authService.passwordRecovery(code, password, passwordConfirmation).pipe(map(data => authActions.passwordRecoverySuccess({\n          payload: data\n        })), catchError(error => of(authActions.passwordRecoveryFailure({\n          error: error\n        }))))));\n      });\n      this.deleteAccount$ = createEffect(() => {\n        return this.actions$.pipe(ofType(authActions.deleteAccount), switchMap(() => this.authService.deleteAccount().pipe(switchMap(x => {\n          return [authActions.deleteAccountSuccess({\n            usuario: x\n          })];\n        }), tap(() => {\n          this.authService.logout();\n          this.shared.sendAlert('success', 'Cuenta Eliminada', 'Su cuenta ha sido Eliminada');\n        }))));\n      });\n      this.backUpAccount$ = createEffect(() => {\n        return this.actions$.pipe(ofType(authActions.backUpAccount), switchMap(({\n          usuario\n        }) => this.authService.deletedAccountBackUp(usuario).pipe(map(x => authActions.deleteAccountSuccess({\n          usuario: x\n        })))));\n      });\n    }\n\n  }\n\n  AuthEffects.ɵfac = function AuthEffects_Factory(t) {\n    return new (t || AuthEffects)(i0.ɵɵinject(i1.Actions), i0.ɵɵinject(i2.AuthService), i0.ɵɵinject(i3.Router), i0.ɵɵinject(i4.Store), i0.ɵɵinject(i5.SharedService));\n  };\n\n  AuthEffects.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthEffects,\n    factory: AuthEffects.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthEffects;\n})();","map":null,"metadata":{},"sourceType":"module"}