{"ast":null,"code":"import { createEffect, ofType } from '@ngrx/effects';\nimport { select } from '@ngrx/store';\nimport { catchError, map, of, switchMap, tap, withLatestFrom } from 'rxjs';\nimport { PAWLLocalStorage } from 'src/app/exports/enums';\nimport * as fromCart from '../actions/cart.actions';\nimport { socketEmit } from '../actions/socket.actions';\nimport { cartFeatureKey } from '../reducers/cart.reducer';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/effects\";\nimport * as i2 from \"@ngrx/store\";\nimport * as i3 from \"../../entities/services/product.service\";\nimport * as i4 from \"../services/cart.service\";\nimport * as i5 from \"@angular/router\";\nimport * as i6 from \"src/app/modules/shared/shared.service\";\nexport let CartEffects = /*#__PURE__*/(() => {\n  class CartEffects {\n    constructor(actions$, store, productService, cartService, router, shared) {\n      this.actions$ = actions$;\n      this.store = store;\n      this.productService = productService;\n      this.cartService = cartService;\n      this.router = router;\n      this.shared = shared;\n      this.saveCart$ = createEffect(() => this.actions$.pipe(ofType(fromCart.saveCart), withLatestFrom(this.store.pipe(select(cartFeatureKey))), tap(([x, {\n        products\n      }]) => {\n        localStorage.setItem(PAWLLocalStorage.CART, JSON.stringify(products));\n      })), {\n        dispatch: false\n      });\n      this.clearCart$ = createEffect(() => this.actions$.pipe(ofType(fromCart.clearCart), tap(() => {\n        localStorage.removeItem(PAWLLocalStorage.CART);\n      })), {\n        dispatch: false\n      });\n      this.loadSavedCart$ = createEffect(() => this.actions$.pipe(ofType(fromCart.loadSavedCart), switchMap(() => {\n        // Todo: Load cart from backend\n        let actions = [];\n        localStorage.getItem(PAWLLocalStorage.CART) && actions.push(fromCart.loadSavedSuccess({\n          cart: JSON.parse(localStorage.getItem(PAWLLocalStorage.CART))\n        }));\n        return actions;\n      })));\n      this.modifyCart$ = createEffect(() => this.actions$.pipe(ofType(fromCart.modifyCart), // Select cart from store with lastestValue pipe\n      withLatestFrom(this.store.pipe(select(cartFeatureKey))), switchMap(([payload, state]) => {\n        let actions = []; // if quantity is 0, remove product from cart\n\n        if (state.products.find(x => x.product.id === payload.itemID).quantity === 0) {\n          actions.push(fromCart.removeProductFromCart({\n            productID: payload.itemID\n          }));\n        }\n\n        actions.push(fromCart.saveCart());\n        return actions;\n      })));\n      this.addProductToCart$ = createEffect(() => this.actions$.pipe(ofType(fromCart.addProductToCart), switchMap(action => {\n        return of(fromCart.saveCart());\n      }), tap(() => {\n        this.shared.sendAlert('success', 'Agregado', 'Su Producto ha sido agregado al carrito');\n      })));\n      this.addProductsToCart$ = createEffect(() => this.actions$.pipe(ofType(fromCart.addProductsToCart), switchMap(action => {\n        return of(fromCart.saveCart());\n      }), tap(() => {\n        this.shared.sendAlert('success', 'Agregado', 'Su Producto ha sido agregado al carrito');\n      })));\n      this.removeProductFromCart$ = createEffect(() => this.actions$.pipe(ofType(fromCart.removeProductFromCart), switchMap(action => {\n        return of(fromCart.saveCart());\n      })));\n      this.createPayment$ = createEffect(() => this.actions$.pipe(ofType(fromCart.createPayment), switchMap(({\n        token,\n        orderID,\n        amount\n      }) => {\n        return this.cartService.createPayment(token, orderID, amount).pipe(switchMap(x => {\n          console.log(x);\n\n          if (x.error) {\n            this.shared.sendAlert('warning', 'Error', ' Error al procesar el pago, intente con otra tarjeta');\n            return of(fromCart.errorPayment(x));\n          }\n\n          if (!!x.data.returnUrl) {\n            // If payment needs a 3ds confirmation\n            window.location.href = x.data.returnUrl;\n            return [];\n          } else {\n            return of(fromCart.updatePaymentResponse({\n              paymentResponse: x.data,\n              orderID\n            }));\n          }\n        }), catchError(error => {\n          return of(fromCart.error({\n            error\n          }));\n        }));\n      }))); // confirmPayment$ = createEffect(() =>\n      //     this.actions$.pipe(\n      //         ofType(fromCart.confirmPayment),\n      //         switchMap((action) => {\n      //             return of(fromCart.updatePaymentResponse({ paymentResponse: action.token, orderID:  }));\n      //         })\n      //     )\n      // );\n\n      this.createOrder$ = createEffect(() => this.actions$.pipe(ofType(fromCart.createOrder), switchMap(({\n        addressID\n      }) => {\n        return this.cartService.createOrder(addressID).pipe(switchMap(x => {\n          return [fromCart.clearCart(), fromCart.createOrderSuccess({\n            response: x\n          })];\n        }), catchError(error => {\n          return of(fromCart.error({\n            error\n          }));\n        }));\n      })));\n      this.updatePaymentResponse$ = createEffect(() => {\n        return this.actions$.pipe(ofType(fromCart.updatePaymentResponse), switchMap(({\n          orderID,\n          paymentResponse\n        }) => this.cartService.updatePaymentResponse(orderID, paymentResponse).pipe(map(data => fromCart.updatePaymentResponseSuccess({\n          order: data\n        })), catchError(error => of(fromCart.updatePaymentResponseFailure({\n          error\n        }))))));\n      });\n      this.updatePaymentResponseSuccess$ = createEffect(() => this.actions$.pipe(ofType(fromCart.updatePaymentResponseSuccess), switchMap(action => {\n        this.router.navigate(['/shop', 'orders']);\n        return [socketEmit({\n          payload: action.order,\n          room: 'orders'\n        }), fromCart.clearCart()];\n      })));\n      this.getNetpayClient$ = createEffect(() => {\n        return this.actions$.pipe(ofType(fromCart.getNetpayClient), switchMap(() => this.cartService.getNetpayClient().pipe(map(data => fromCart.getNetpayClientSuccess({\n          userPayload: data\n        })), catchError(error => of(fromCart.error({\n          error\n        })))) // TODO: Cambiarlo, no se va a encontrar un cliente, no tirar un error, simplemente no hacer nada\n        ));\n      });\n      this.error$ = createEffect(() => this.actions$.pipe(ofType(fromCart.error), tap(x => {\n        console.error(x);\n      })), {\n        dispatch: false\n      });\n    }\n\n  }\n\n  CartEffects.ɵfac = function CartEffects_Factory(t) {\n    return new (t || CartEffects)(i0.ɵɵinject(i1.Actions), i0.ɵɵinject(i2.Store), i0.ɵɵinject(i3.ProductService), i0.ɵɵinject(i4.CartService), i0.ɵɵinject(i5.Router), i0.ɵɵinject(i6.SharedService));\n  };\n\n  CartEffects.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: CartEffects,\n    factory: CartEffects.ɵfac,\n    providedIn: 'root'\n  });\n  return CartEffects;\n})();","map":null,"metadata":{},"sourceType":"module"}